module Snail.Types where

import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Display (Display (..), display)
import Data.Text.Lazy.Builder qualified as B
import Text.Megaparsec
import Data.Void (Void)

-- | TODO: 'Void' is the error type but we should probably use an explicit error type
type Parser = Parsec Void Text

data Keyword
  = Nil
  | Lambda
  | If
  | Let
  deriving (Eq, Show, Display)

data Expression
  = Atom Text
  | Boolean Bool
  | Number Integer
  | TextLiteral Text
  | Nil
  | Lambda
  | If
  | Let
  deriving (Eq)

instance Display Expression where
  displayBuilder = \case
    Nil -> "Nil"
    Atom expr -> B.fromText expr
    Boolean True -> "#t"
    Boolean False -> "#f"
    Number int -> displayBuilder int
    TextLiteral str -> "\"" <> B.fromText str <> "\""
    Quote ast -> "'" <> displayBuilder ast
    List exprs -> "(" <> B.fromText (T.unwords (display <$> exprs)) <> ")"
    Lambda exprs ast -> "<lambda (" <> B.fromText (T.unwords (display <$> exprs)) <> ") (" <> displayBuilder ast <> ")>"

instance Show Expression where
  show = T.unpack . display
